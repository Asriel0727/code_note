# 設計模式的種類
### 1.Creational Pattern 創建型模式
>用於描述如何**建立物件**，主要核心為把物件的建立和使用分開。

|模式名稱|英文|簡介 |
|------|---|-----|
|工廠模式|Factory|提供物件建立在superclass/parentclass的介面(interface)，同時也讓subclass/childclass 決定實體化的類別(class)為何|
|抽象工廠|Abstract factory|提供一個封裝一系列相關或相互依賴物件的介面，而不需去指定它們具體的類別|
|單例模式|Singleton|限制了每一個類別的初始化，並保證一個類別裡只有一個instance可以被創建|
|原型模式|Prototype|從一個相似的Instance建立一個新的物件，再根據我們的需求調整|
|建造者模式|Builder|一步步使用一些簡單的物件去建構一個較複雜的物件|

---

### 2.Structural Pattern 結構型模式
>描述了在保持原結構的彈性和效能下，如何將類別或物件透過複合(composition)、繼承(inheritance)的方式，建構出更大更複雜的架構。

|模式名稱|英文|簡介 |
|------|---|-----|
|轉接器模式|Adapter|使介面不相容的類別能夠一起工作，就像兩個不相容物件的橋梁一樣|
|橋接模式|Bridge|將一個大型類別或一組密切相關的類別分為兩個獨立的層次結構——抽象層和實作層，這兩者可以獨立地進行開發而互不影響|
|組合模式|Composite|將物件組合成樹狀結構，然後以結構的方式處理它們，就好像它們是個別的物件一樣|
|裝飾者模式|Decorator|通過將物件放置在包含特定行為的特殊包裝物件中，來附加新的行為到這些物件上|
|外觀模式|Facade|提供了一個簡化的介面給一個library、框架或任何其他複雜的類別集合|
|享元模式|Flyweight|讓使用者在有限的記憶體內，透過共享多個物件所擁有的共同狀態，來載入更多物件;而不是在每個物件中保存所有資料|
|代理模式|Proxy|為另一個物件提供一個substitute或是placeholder。用來控制對原始物件的訪問，並允許使用者在把請求傳遞到原始物件之前或之後執行某些操作或處理|

---

### 3.Behavioral Pattern 行為型模式
>描述物或類別之間如何溝通協作。

|模式名稱|英文|簡介 |
|------|---|-----|
|責任鏈模式|Chain of Responsibility|將請求依次傳遞給一系列處理者。在收到請求後，每個處理者決定是處理該請求還是將其傳遞給鏈中的下一個處理者|
|命令模式|Command|將一個請求轉換成一個擁有包含請求資訊的獨立物件。這種轉換使你能夠將請求作為方法引數傳遞，延遲或佇列請求的執行，並實現可撤銷的操作|
|組合模式|Interpreter|它用於處理解釋和解析語言或表達式的需求。它的主要目的是將一個語言或表達式解釋成可執行的操作或行為。這種模式通常在編譯器、計算機語言解釋器、數學公式解析器等情境下使用|
|迭代器模式|Iterator|在不暴露其集合的底層表現形式(清單、堆疊、樹等)的情況下，走訪集合中的各個元素|
|中介者模式|Mediator|減少物件和物件之間混亂的相依性。這個模式限制了物件之間的直接溝通，強制讓它們透過一個中介者物件來合作|
|備忘錄模式|Memento|在不揭露實作的細節的情況下，儲存且恢復物件德原始狀態|
|觀察者模式|Observer|定義一種訂閱的機制，以通知多個物件有關它們正在觀察的物件 的任何事件|
|狀態模式|State|允許物件在內部狀態改變時改變自身的行為。使其看起來就像改變了它的所屬類別|
|觀察者模式|Strategy|定義一系列的演算法，將每個演算法放入獨立的類別中，並使它們的物件可以相互替換|
|模板方法模式|Template|在父類別定義了一種演算法的骨架，允許子類別在不修改結構的情況下覆寫特定步驟|
|訪問者模式|Visitor|將演算法從它們作用的物件中分離出來|
---